<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dollar Stack Visualizer</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        overflow: hidden;
        background-color: #f0f0f0;
      }

      #container {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      #controls {
        padding: 20px;
        background-color: #fff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        z-index: 10;
        display: flex;
        align-items: center;
        gap: 15px;
      }

      #amount {
        padding: 8px;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 4px;
        width: 150px;
      }

      #render-btn {
        padding: 8px 16px;
        font-size: 16px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      #render-btn:hover {
        background-color: #45a049;
      }

      #info {
        margin-left: 20px;
        font-size: 16px;
      }

      #canvas-container {
        flex: 1;
        position: relative;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="controls">
        <label for="amount">Amount in dollars:</label>
        <input type="number" id="amount" min="0" step="100" value="100000" />
        <button id="render-btn">Render</button>
        <div id="info">0 x 100$ bill</div>
      </div>
      <div id="canvas-container"></div>
    </div>

    <!-- Using older cannon.js instead of cannon-es -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
      // Main application
      const app = {
        // Scene setup
        scene: null,
        camera: null,
        renderer: null,
        controls: null,

        // Physics
        world: null,
        timeStep: 1 / 60,

        // Objects
        bills: [],
        billMesh: null,
        billTexture: null,

        // Configuration
        ENABLE_NAVIGATION: true, // Flag to enable/disable 3D navigation

        // DOM elements
        amountInput: document.getElementById("amount"),
        renderBtn: document.getElementById("render-btn"),
        infoElement: document.getElementById("info"),

        // Initialize the application
        init() {
          this.setupThree();
          this.setupPhysics();
          this.setupLights();
          this.setupGround();
          this.loadBillTexture();
          this.setupEventListeners();

          // Render bills immediately after initialization
          this.renderBills();

          this.animate();
        },

        // Set up Three.js scene, camera, renderer
        setupThree() {
          // Create scene
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0xf0f0f0);

          // Create camera
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.camera.position.set(0, 10, 20);

          // Create renderer
          this.renderer = new THREE.WebGLRenderer({ antialias: true });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.renderer.shadowMap.enabled = true;
          document
            .getElementById("canvas-container")
            .appendChild(this.renderer.domElement);

          // Add orbit controls but disable rotation
          this.controls = new THREE.OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          this.controls.enableRotate = this.ENABLE_NAVIGATION; // Enable/disable rotation based on flag
          this.controls.enablePan = this.ENABLE_NAVIGATION; // Enable/disable panning based on flag
          this.controls.enableZoom = true; // Allow zooming regardless of flag
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;

          // Handle window resize
          window.addEventListener("resize", () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
          });

          // Setup raycaster for interaction
          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
          this.selectedBill = null;
          this.intersectedBill = null;
        },

        // Set up physics world
        setupPhysics() {
          // Create a world with gravity but we won't be adding bodies to it
          this.world = new CANNON.World();
          this.world.gravity.set(0, -9.82, 0);
        },

        // Set up lights
        setupLights() {
          // Ambient light
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
          this.scene.add(ambientLight);

          // Directional light (sun)
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(10, 20, 10);
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.width = 2048;
          directionalLight.shadow.mapSize.height = 2048;
          directionalLight.shadow.camera.near = 0.5;
          directionalLight.shadow.camera.far = 50;
          directionalLight.shadow.camera.left = -20;
          directionalLight.shadow.camera.right = 20;
          directionalLight.shadow.camera.top = 20;
          directionalLight.shadow.camera.bottom = -20;
          this.scene.add(directionalLight);
        },

        // Set up ground plane
        setupGround() {
          // Three.js ground
          const groundGeometry = new THREE.PlaneGeometry(50, 50);
          const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x999999,
            roughness: 0.8,
            metalness: 0.2,
          });
          const ground = new THREE.Mesh(groundGeometry, groundMaterial);
          ground.rotation.x = -Math.PI / 2;
          ground.receiveShadow = true;
          this.scene.add(ground);

          // Cannon.js ground - updated for old Cannon.js syntax
          const groundShape = new CANNON.Plane();
          const groundBody = new CANNON.Body({
            mass: 0,
          });
          groundBody.addShape(groundShape);
          groundBody.quaternion.setFromAxisAngle(
            new CANNON.Vec3(1, 0, 0),
            -Math.PI / 2
          );
          this.world.addBody(groundBody);
        },

        // Load bill texture
        loadBillTexture() {
          const textureLoader = new THREE.TextureLoader();
          this.billTexture = textureLoader.load(
            "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Usdollar100front.jpg/2560px-Usdollar100front.jpg",
            // Add onLoad callback to handle texture loading
            () => {
              console.log("Texture loaded successfully");
            },
            // Add onProgress callback (optional)
            undefined,
            // Add onError callback
            (err) => {
              console.error("Error loading texture:", err);
            }
          );

          // Create bill geometry (100 dollar bill dimensions: 156mm x 66.3mm x 0.11mm)
          // Using realistic dimensions
          const billWidth = 1.56;
          const billHeight = 0.663;
          const billThickness = 0.0011; // Realistische Dicke: 0.11mm = 0.0011 Einheiten

          const billGeometry = new THREE.BoxGeometry(
            billWidth,
            billThickness,
            billHeight
          );

          // Create materials for the bill
          const frontMaterial = new THREE.MeshStandardMaterial({
            map: this.billTexture,
            roughness: 0.5,
            metalness: 0.1,
          });
          const backMaterial = new THREE.MeshStandardMaterial({
            color: 0x85bb65,
            roughness: 0.5,
            metalness: 0.2,
          });
          const edgeMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc,
            roughness: 0.5,
            metalness: 0.1,
          });

          const materials = [
            edgeMaterial, // right side
            edgeMaterial, // left side
            frontMaterial, // top (front of bill)
            backMaterial, // bottom (back of bill)
            edgeMaterial, // front edge
            edgeMaterial, // back edge
          ];

          this.billMesh = new THREE.Mesh(billGeometry, materials);
          this.billMesh.castShadow = true;
          this.billMesh.receiveShadow = true;
        },

        // Set up event listeners
        setupEventListeners() {
          this.renderBtn.addEventListener("click", this.renderBills.bind(this));

          // Use mousedown for bill selection
          this.renderer.domElement.addEventListener("mousedown", (event) => {
            if (event.button === 0) {
              // Left mouse button
              this.handleBillSelection(event);
            }
          });

          // Use mousemove for bill dragging
          this.renderer.domElement.addEventListener("mousemove", (event) => {
            if (this.selectedBill) {
              this.handleBillDragging(event);
            }
          });

          // Use mouseup to release bill
          this.renderer.domElement.addEventListener("mouseup", (event) => {
            if (event.button === 0) {
              // Left mouse button
              this.selectedBill = null;
            }
          });
        },

        handleBillSelection(event) {
          // Calculate mouse position
          this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

          this.raycaster.setFromCamera(this.mouse, this.camera);
          const intersects = this.raycaster.intersectObjects(
            this.bills.map((bill) => bill.mesh)
          );

          if (intersects.length > 0) {
            // Find the bill that was clicked
            const selectedMesh = intersects[0].object;
            for (const bill of this.bills) {
              if (
                bill.mesh === selectedMesh ||
                bill.mesh.id === selectedMesh.id
              ) {
                this.selectedBill = bill;
                break;
              }
            }
          }
        },

        handleBillDragging(event) {
          // Calculate mouse position
          this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

          this.raycaster.setFromCamera(this.mouse, this.camera);
          const planeIntersection = new THREE.Vector3();
          const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
          this.raycaster.ray.intersectPlane(dragPlane, planeIntersection);

          // Move the bill to follow the mouse
          this.selectedBill.body.position.x = planeIntersection.x;
          this.selectedBill.body.position.z = planeIntersection.z;
          this.selectedBill.body.position.y = Math.max(
            0.1,
            planeIntersection.y
          );
          this.selectedBill.body.velocity.set(0, 0, 0);
          this.selectedBill.body.angularVelocity.set(0, 0, 0);
          this.selectedBill.body.wakeUp();
        },

        // Render bills based on input amount
        renderBills() {
          // Clear existing bills
          this.clearBills();

          // Get amount and round to nearest $100
          let amount = parseFloat(this.amountInput.value);
          if (isNaN(amount)) amount = 0;

          // Round to nearest $100
          amount = Math.round(amount / 100) * 100;
          this.amountInput.value = amount;

          // Calculate number of bills
          const numBills = amount / 100;

          // Format numbers with thousand separators
          const formattedNumBills = numBills.toLocaleString();
          const formattedAmount = amount.toLocaleString();
          this.infoElement.textContent = `${formattedNumBills} x 100$ bill = $${formattedAmount}`;

          if (numBills <= 0) return;

          // Bill dimensions
          const billWidth = 1.56;
          const billHeight = 0.663;
          const billThickness = 0.0011;

          // Each stack represents $10,000 (100 bills)
          const billsPerStack = 100;
          const numStacks = Math.ceil(numBills / billsPerStack);

          // Calculate optimal grid dimensions
          const stackHeight = billThickness * billsPerStack;
          const totalVolume = numStacks * billWidth * billHeight * stackHeight;
          const targetWidth = Math.pow(totalVolume * 1.5, 1 / 3);

          // Calculate grid dimensions based on bill aspect ratio
          const aspectRatio = billWidth / billHeight;
          const targetRatio = Math.sqrt(aspectRatio);

          // Calculate grid dimensions (columns and rows)
          let gridX = Math.ceil(Math.sqrt(numStacks / targetRatio));
          let gridZ = Math.ceil(numStacks / gridX);

          // Calculate how many layers we need to achieve the target height
          const targetHeight = (targetWidth * 2) / 3;
          const layersNeeded = Math.ceil(targetHeight / stackHeight);

          // Recalculate grid dimensions with layers
          if (layersNeeded > 1) {
            const stacksPerLayer = Math.ceil(numStacks / layersNeeded);
            gridX = Math.ceil(Math.sqrt(stacksPerLayer / targetRatio));
            gridZ = Math.ceil(stacksPerLayer / gridX);
          }

          // Base spacing on bill dimensions
          const spacingX = billWidth * 1.15; // Horizontal spacing with small gap
          const spacingZ = billHeight * 1.15; // Vertical spacing proportional to bill height

          // Calculate stacks per layer
          const stacksPerLayer = gridX * gridZ;
          const numLayers = Math.ceil(numStacks / stacksPerLayer);

          // Create a map to store bills at each grid position
          const gridPositions = new Map();
          let remainingBills = numBills;

          // Distribute bills to grid positions
          for (let layer = 0; layer < numLayers; layer++) {
            for (let row = 0; row < gridZ; row++) {
              for (let col = 0; col < gridX; col++) {
                if (remainingBills <= 0) break;

                // Calculate position key based only on horizontal position (x,z)
                const posKey = `${row},${col}`;

                // Calculate bills in this stack
                const stackBills = Math.min(billsPerStack, remainingBills);
                remainingBills -= stackBills;

                // Calculate position
                const offsetX = (col - (gridX - 1) / 2) * spacingX;
                const offsetZ = (row - (gridZ - 1) / 2) * spacingZ;

                // Add to existing position or create new entry
                if (gridPositions.has(posKey)) {
                  // Add bills to existing stack at this x,z position
                  gridPositions.get(posKey).bills += stackBills;
                } else {
                  // Create new entry at this x,z position
                  gridPositions.set(posKey, {
                    x: offsetX,
                    y: 0, // Start at ground level
                    z: offsetZ,
                    bills: stackBills,
                  });
                }
              }
              if (remainingBills <= 0) break;
            }
            if (remainingBills <= 0) break;
          }

          // Create stacks for each grid position
          let stacksCreated = 0;
          console.log(gridPositions);

          for (const [_, position] of gridPositions) {
            this.createVisualStack(
              position.x,
              position.y,
              position.z,
              position.bills
            );
            stacksCreated++;
          }

          // Update info with stack count
          this.infoElement.textContent = `${formattedNumBills} x 100$ bill = $${formattedAmount} (${stacksCreated.toLocaleString()} stacks created)`;
        },

        // Create a visual stack of bills without physics - optimized version
        createVisualStack(x, y, z, numBills) {
          const billWidth = 1.56;
          const billHeight = 0.663;
          const billThickness = 0.0011;

          // Calculate stack height
          const stackHeight = billThickness * numBills;

          // Create a group to hold the stack
          const stackGroup = new THREE.Group();
          stackGroup.position.set(x, y, z);
          this.scene.add(stackGroup);

          // Create main stack geometry (one big box instead of individual bills)
          const stackGeometry = new THREE.BoxGeometry(
            billWidth,
            stackHeight,
            billHeight
          );

          // Use simple materials without textures for better performance
          const frontMaterial = new THREE.MeshStandardMaterial({
            map: this.billTexture,
            roughness: 0.5,
            metalness: 0.1,
          });

          const backMaterial = new THREE.MeshStandardMaterial({
            color: 0x85bb65,
            roughness: 0.5,
            metalness: 0.2,
          });

          // Simple edge material without lines
          const edgeMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc,
            roughness: 0.5,
            metalness: 0.1,
          });

          const materials = [
            edgeMaterial, // right side
            edgeMaterial, // left side
            frontMaterial, // top (front of bill)
            backMaterial, // bottom (back of bill)
            edgeMaterial, // front edge
            edgeMaterial, // back edge
          ];

          const stackMesh = new THREE.Mesh(stackGeometry, materials);
          stackMesh.castShadow = true;
          stackMesh.receiveShadow = true;

          // Position the stack so its bottom is at y=0
          stackMesh.position.y = stackHeight / 2;

          stackGroup.add(stackMesh);

          // Only add top bill for smaller stacks to improve performance
          if (numBills > 0 && numBills < 50) {
            const topBill = this.billMesh.clone();
            topBill.position.y = stackHeight + billThickness / 2;
            stackGroup.add(topBill);
          }

          // Store reference to the stack
          this.bills.push({
            mesh: stackGroup,
            billCount: numBills,
            isVisualStack: true,
          });
        },

        // Clear all bills
        clearBills() {
          for (const bill of this.bills) {
            this.scene.remove(bill.mesh);
            // Only remove physics bodies if they exist
            if (bill.body) {
              this.world.removeBody(bill.body);
            }
          }
          this.bills = [];
        },

        // Animation loop - simplified without physics
        animate() {
          requestAnimationFrame(this.animate.bind(this));

          // No physics updates needed

          // Update controls
          this.controls.update();

          // Render scene
          this.renderer.render(this.scene, this.camera);
        },

        // New method for instanced rendering of very large amounts
        createInstancedBillStacks(numBills) {
          const billWidth = 1.56;
          const billHeight = 0.663;
          const billThickness = 0.0011;

          // Each stack represents $10,000 (100 bills)
          const billsPerStack = 100;
          const numStacks = Math.ceil(numBills / billsPerStack);

          // Calculate grid dimensions
          const gridSize = Math.ceil(Math.sqrt(numStacks));
          const spacing = Math.max(billWidth, billHeight) * 1.2;

          // Create instanced mesh for stacks
          const stackGeometry = new THREE.BoxGeometry(
            billWidth,
            billThickness * billsPerStack,
            billHeight
          );

          // Simple material for all instances
          const stackMaterial = [
            new THREE.MeshStandardMaterial({
              color: 0xcccccc,
              roughness: 0.5,
              metalness: 0.1,
            }), // right
            new THREE.MeshStandardMaterial({
              color: 0xcccccc,
              roughness: 0.5,
              metalness: 0.1,
            }), // left
            new THREE.MeshStandardMaterial({
              map: this.billTexture,
              roughness: 0.5,
              metalness: 0.1,
            }), // top
            new THREE.MeshStandardMaterial({
              color: 0x85bb65,
              roughness: 0.5,
              metalness: 0.2,
            }), // bottom
            new THREE.MeshStandardMaterial({
              color: 0xcccccc,
              roughness: 0.5,
              metalness: 0.1,
            }), // front
            new THREE.MeshStandardMaterial({
              color: 0xcccccc,
              roughness: 0.5,
              metalness: 0.1,
            }), // back
          ];

          const instancedMesh = new THREE.InstancedMesh(
            stackGeometry,
            stackMaterial,
            numStacks
          );

          instancedMesh.castShadow = true;
          instancedMesh.receiveShadow = true;
          this.scene.add(instancedMesh);

          // Create matrix for each instance
          const matrix = new THREE.Matrix4();
          const stackHeight = billThickness * billsPerStack;

          for (let i = 0; i < numStacks; i++) {
            const row = Math.floor(i / gridSize);
            const col = i % gridSize;

            const x = (col - gridSize / 2) * spacing;
            const z = (row - gridSize / 2) * spacing;
            const y = stackHeight / 2;

            matrix.setPosition(x, y, z);
            instancedMesh.setMatrixAt(i, matrix);
          }

          instancedMesh.instanceMatrix.needsUpdate = true;

          // Store reference
          this.bills.push({
            mesh: instancedMesh,
            billCount: numBills,
            isVisualStack: true,
            isInstanced: true,
          });

          // Update info
          const formattedNumBills = numBills.toLocaleString();
          const formattedAmount = (numBills * 100).toLocaleString();
          this.infoElement.textContent = `${formattedNumBills} x 100$ bill = $${formattedAmount} (${numStacks.toLocaleString()} stacks using instanced rendering)`;
        },
      };

      // Initialize when the page loads
      window.addEventListener("load", () => {
        app.init();
      });
    </script>
  </body>
</html>
